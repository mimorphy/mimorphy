#ifndef FIXED_LENGTH_STRING
#define FIXED_LENGTH_STRING

#include <basic>
#include <array>

using std::array;

str fixed_length(const char* str);
str fixed_length(const char* str, sizevalue len);
str fixed_length(const byte_array& str);

template<sizevalue N>
constexpr auto STR(const char(&str)[N])
{
	sizevalue char_count = 0;
	for (sizevalue i = 0; i < N - 1 && str[i] != '\0'; ) {
		unsigned char c = static_cast<unsigned char>(str[i]);
		if (c < 0x80) i += 1;
		else if ((c & 0xE0) == 0xC0) i += 2;
		else if ((c & 0xF0) == 0xE0) i += 3;
		else if ((c & 0xF8) == 0xF0) i += 4;
		else i += 1;
		++char_count;
	}

	array<char32_t, N> result{};
	sizevalue idx = 0;
	sizevalue i = 0;

	while (i < N - 1 && str[i] != '\0') {
		unsigned char c = static_cast<unsigned char>(str[i]);
		char32_t cp = 0;

		if (c < 0x80) {
			cp = c;
			i += 1;
		}
		else if ((c & 0xE0) == 0xC0 && i + 1 < N) {
			cp = ((c & 0x1F) << 6) | (static_cast<unsigned char>(str[i + 1]) & 0x3F);
			i += 2;
		}
		else if ((c & 0xF0) == 0xE0 && i + 2 < N) {
			cp = ((c & 0x0F) << 12) |
				((static_cast<unsigned char>(str[i + 1]) & 0x3F) << 6) |
				(static_cast<unsigned char>(str[i + 2]) & 0x3F);
			i += 3;
		}
		else if ((c & 0xF8) == 0xF0 && i + 3 < N) {
			cp = ((c & 0x07) << 18) |
				((static_cast<unsigned char>(str[i + 1]) & 0x3F) << 12) |
				((static_cast<unsigned char>(str[i + 2]) & 0x3F) << 6) |
				(static_cast<unsigned char>(str[i + 3]) & 0x3F);
			i += 4;
		}
		else {
			cp = 0xFFFD;
			i += 1;
		}

		result[idx++] = cp;
	}

	result[idx] = U'\0';
	return result;
}

// 运行时版本的 UTF-8 到 char32_t 转换函数
template<sizevalue N>
str fixed_length(const char(&cstr)[N])
{
	// 计算需要的字符数量
	sizevalue char_count = 0;
	for (sizevalue i = 0; i < N - 1 && cstr[i] != '\0'; ) {
		unsigned char c = static_cast<unsigned char>(cstr[i]);
		if (c < 0x80) i += 1;
		else if ((c & 0xE0) == 0xC0) i += 2;
		else if ((c & 0xF0) == 0xE0) i += 3;
		else if ((c & 0xF8) == 0xF0) i += 4;
		else i += 1;
		++char_count;
	}

	// 使用 str 存储结果（动态分配）
	str result;
	result.reserve(char_count + 1); // 预分配空间提高效率

	sizevalue i = 0;

	while (i < N - 1 && cstr[i] != '\0') {
		unsigned char c = static_cast<unsigned char>(cstr[i]);
		char32_t cp = 0;

		if (c < 0x80) {
			cp = c;
			i += 1;
		}
		else if ((c & 0xE0) == 0xC0 && i + 1 < N) {
			// 检查 continuation bytes
			unsigned char c2 = static_cast<unsigned char>(cstr[i + 1]);
			cp = ((c & 0x1F) << 6) | (c2 & 0x3F);
			i += 2;
		}
		else if ((c & 0xF0) == 0xE0 && i + 2 < N) {
			unsigned char c2 = static_cast<unsigned char>(cstr[i + 1]);
			unsigned char c3 = static_cast<unsigned char>(cstr[i + 2]);
			cp = ((c & 0x0F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);
			i += 3;
		}
		else if ((c & 0xF8) == 0xF0 && i + 3 < N) {
			unsigned char c2 = static_cast<unsigned char>(cstr[i + 1]);
			unsigned char c3 = static_cast<unsigned char>(cstr[i + 2]);
			unsigned char c4 = static_cast<unsigned char>(cstr[i + 3]);
			cp = ((c & 0x07) << 18) | ((c2 & 0x3F) << 12) |
				((c3 & 0x3F) << 6) | (c4 & 0x3F);
			i += 4;
		}
		else {
			cp = 0xFFFD; // Unicode 替换字符
			i += 1;
		}

		result.push_back(cp);
	}

	return result;
}

// 重载版本：接受 byte_array 参数
str fixed_length(const byte_array& bstr);

// 重载版本：接受 C 风格字符串指针
str fixed_length(const char* cstr);

// 重载版本：接受指针和长度
str fixed_length(const char* cstr, sizevalue len);

// 将定长字符串转换成字节串
byte_array variable_length(const str& u32str);

#endif