#ifndef BIT_SPAN
#define BIT_SPAN

#include <cstddef>
#include <iterator>
#include <stdexcept>
#include <algorithm>

// 比特引用代理类
class bit_reference
{
    unsigned char* byte_ptr_; // 指向包含目标比特的字节
    size_t bit_pos_; // 比特在字节中的位置 (0-7)

public:
    bit_reference(unsigned char* byte_ptr, size_t bit_pos) noexcept;

    // 转换为 bool (读取比特值)
    operator bool() const noexcept;

    // 赋值操作 (设置比特值)
    bit_reference& operator=(bool value) noexcept;

    // 从另一个比特引用赋值
    bit_reference& operator=(const bit_reference& other) noexcept;

    // 翻转比特
    void flip() noexcept;
};

// 可变比特迭代器
class bit_iterator
{
public:
    using iterator_category = std::random_access_iterator_tag;
    using value_type = bool;
    using difference_type = std::ptrdiff_t;
    using reference = bit_reference;
    using pointer = void; // 指针类型不适用

public:
    unsigned char* byte_ptr_; // 当前字节指针
    size_t bit_pos_; // 当前比特在字节中的位置 (0-7)

public:
    bit_iterator(unsigned char* ptr, size_t bit_pos) noexcept;

    // 解引用
    reference operator*() const;

    // 前置递增
    bit_iterator& operator++();

    // 后置递增
    bit_iterator operator++(int);

    // 前置递减
    bit_iterator& operator--();

    // 后置递减
    bit_iterator operator--(int);

    // 随机访问：迭代器 + n
    bit_iterator operator+(difference_type n) const;

    // 随机访问：n + 迭代器
    friend bit_iterator operator+(difference_type n, const bit_iterator& it);

    // 随机访问：迭代器 - n
    bit_iterator operator-(difference_type n) const;

    // 迭代器差值
    difference_type operator-(const bit_iterator& other) const;

    // 复合赋值 +=
    bit_iterator& operator+=(difference_type n);

    // 复合赋值 -=
    bit_iterator& operator-=(difference_type n);

    // 下标访问
    reference operator[](difference_type n) const;

    unsigned char* byte_ptr() const noexcept {
        return byte_ptr_;
    }

    size_t bit_offset() const noexcept {
        return bit_pos_;
    }

    // 比较运算符
    bool operator==(const bit_iterator& other) const noexcept;
    bool operator!=(const bit_iterator& other) const noexcept;
    bool operator<(const bit_iterator& other) const noexcept;
    bool operator<=(const bit_iterator& other) const noexcept;
    bool operator>(const bit_iterator& other) const noexcept;
    bool operator>=(const bit_iterator& other) const noexcept;
};

// 常量比特迭代器
class const_bit_iterator
{
public:
    using iterator_category = std::random_access_iterator_tag;
    using value_type = bool;
    using difference_type = std::ptrdiff_t;
    using reference = bool;
    using pointer = void; // 指针类型不适用

private:
    const unsigned char* byte_ptr_; // 当前字节指针
    size_t bit_pos_; // 当前比特在字节中的位置 (0-7)

public:
    const_bit_iterator(const unsigned char* ptr, size_t bit_pos) noexcept;

    // 从可变迭代器构造
    const_bit_iterator(const bit_iterator& other) noexcept;

    // 解引用
    reference operator*() const;

    // 前置递增
    const_bit_iterator& operator++();

    // 后置递增
    const_bit_iterator operator++(int);

    // 前置递减
    const_bit_iterator& operator--();

    // 后置递减
    const_bit_iterator operator--(int);

    // 随机访问：迭代器 + n
    const_bit_iterator operator+(difference_type n) const;

    // 随机访问：n + 迭代器
    friend const_bit_iterator operator+(difference_type n, const const_bit_iterator& it);

    // 随机访问：迭代器 - n
    const_bit_iterator operator-(difference_type n) const;

    // 迭代器差值
    difference_type operator-(const const_bit_iterator& other) const;

    // 复合赋值 +=
    const_bit_iterator& operator+=(difference_type n);

    // 复合赋值 -=
    const_bit_iterator& operator-=(difference_type n);

    // 下标访问
    reference operator[](difference_type n) const;

    const unsigned char* byte_ptr() const noexcept {
        return byte_ptr_;
    }

    size_t bit_offset() const noexcept {
        return bit_pos_;
    }

    // 比较运算符
    bool operator==(const const_bit_iterator& other) const noexcept;
    bool operator!=(const const_bit_iterator& other) const noexcept;
    bool operator<(const const_bit_iterator& other) const noexcept;
    bool operator<=(const const_bit_iterator& other) const noexcept;
    bool operator>(const const_bit_iterator& other) const noexcept;
    bool operator>=(const const_bit_iterator& other) const noexcept;
};

class bit_span
{
public:
    using element_type = unsigned char;
    using value_type = bool;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using pointer = element_type*;
    using const_pointer = const element_type*;
    using reference = bit_reference;
    using const_reference = bool;
    using iterator = bit_iterator;
    using const_iterator = const_bit_iterator;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    static constexpr size_type dynamic_extent = static_cast<size_type>(-1);
private:
    pointer data_;
    size_type bit_offset_;
    size_type size_in_bits_;
public:
    bit_span() noexcept;
    bit_span(pointer data, size_type bit_offset, size_type size_in_bits);
    bit_span(const bit_span& right);
    bit_span(bit_span&& right);
    bit_span(iterator first, iterator last);
    bit_span(const_iterator first, const_iterator last);
    void operator=(const bit_span& right);
    void operator=(bit_span&& right);
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    const_iterator cbegin() const noexcept;
    iterator end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cend() const noexcept;
    reverse_iterator rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    reverse_iterator rend() noexcept;
    const_reverse_iterator rend() const noexcept;
    const_reverse_iterator crend() const noexcept;
    reference front();
    const_reference front() const;
    reference back();
    const_reference back() const;
    reference operator[](size_type idx);
    const_reference operator[](size_type idx) const;
    reference at(size_type idx);
    const_reference at(size_type idx) const;
    pointer data() const noexcept;
    size_type size() const noexcept;
    size_type size_bytes() const noexcept;
    bool empty() const noexcept;
    bit_span first(size_type n) const;
    bit_span last(size_type n) const;
    bit_span subspan(size_type offset, size_type count = dynamic_extent) const;
};

#endif