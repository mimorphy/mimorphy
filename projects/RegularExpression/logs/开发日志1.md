# 1. 将规则表达式字面量转换成NFA

## 1.1 支持连接运算的转换

### 1.1.1 实现存储状态和状态转移路径的结构

使用一种16字节的节点结构，状态节点。

前8个字节存储：

- 转移到该状态所需要匹配的字符。
- 此节点结构的类型。

后8个字节存储此节点默认转移到的下一个节点的索引。

### 1.1.2 定义默认字符节点类型

此节点类型表示转移到该状态所需要匹配的字符是一个默认字符，即按原义进行匹配。

### 1.1.3 定义空转移节点类型

此节点类型表示转移到该状态不需要匹配任何字符。

### 1.1.4 定义任意字符节点类型

此节点类型表示转移到该状态所需要匹配的字符可以是字母表中的任意一个字符。

### 1.1.5 定义NFA结构

NFA结构线性存储数个状态节点结构，可以视为状态节点的数组。

在只支持连接运算的前提下，状态图只需要存储默认字符节点类型或任意字符节点类型，每个节点默认转移到的下一个节点即此节点在状态图中后继的节点。

### 1.1.6 实现字符串的读取

遍历输入的字符串，对读取的字符进行处理。

- 如果是普通字符，直接生成对应的普通字符节点
- 如果是转义字符，则进行转义后生成对应的普通字符节点

### 1.1.7 将最后一个状态节点的默认转移节点设为结束节点

设定结束节点的索引为 sizevalue_max，不实际存储。

## 1.2 支持或运算的转换

### 1.2.1 定义转移节点类型

此节点类型用于补充其他实义节点(如默认字符节点，任意字符节点)的转移路径。

前8个字节将固定，无意义。后8个字节存储允许转移的目标节点在NFA中的索引。

### 1.2.2 定义虚转移节点类型

此节点类型用于表示大于等于0的数量的转移节点类型的线性表，这样，在构建过程中，无论一个节点往后有多少转移路径，都可以只使用一个虚转移节点表示，方便计算索引。

将使用一个虚转移表存储所有虚转移节点对应的转移节点组，类型为动态数组。

前8个字节将固定，无意义。后8个字节存储虚转移节点在虚转移表中的索引。

### 1.2.3 NFA的开头默认为一个虚转移节点

这样保证了开头有多个转移路径去往其他节点时，易于表示。

### 1.2.4 被左括号分割的节点之间需要有一个虚转移节点

这样保证了当括号导致了多转移路径时，括号前方的字符可以自然地转移。

### 1.2.5 在每一对左右括号的作用域内遍历表达式构建字符

如果右括号出现在表达式开头，或者右括号是左括号的后继字符，则认为这个表达式是无效的。

### 1.2.6 前驱就是末尾，后继就是开头

我们使用动态数组作为数据类型，虚转移索引数组作为前驱队列的元素，状态节点索引数组作为后继队列的元素。

初始化时前驱队列默认具有2个元素，其中第一个元素的元素的索引为0(起始状态)；后继队列默认具有1个元素。

遇到左括号时，前驱队列和后继队列均在末尾添加一个元素，前驱队列在末尾添加元素之前在原本的末尾的末尾添加一个元素，为左括号分割的节点之间的虚转移节点的索引。后继队列添加的元素也要有一个占位元素。

遇到右括号时，前驱队列移除倒数第二个元素，后继队列在末尾移除一个元素。

前驱队列[n]与后继队列[n]是对应的，写入前驱队列时默认往最后一个元素中写入，写入后继队列时默认往最后一个元素中写入。注意，前驱就是末尾，指的是表达式末尾的字符节点是下一个表达式的前驱；后继就是开头，指的是表达式开头的字符节点是上一个表达式的后继。

由于存在默认转移路径，因此最前的前驱节点不需要被记录，最后的后继节点不需要被记录，它们通过字符间的默认连接关系连接。

这样，我们就能通过一一对应的前驱和后继，连接起或运算形成的网络。

### 1.2.7 将NFA中的所有虚转移节点都展开为转移节点

首先，遍历一遍NFA的每个节点，建立一个映射表，从节点原本的索引映射到虚转移展开后的索引。

然后，将虚转移节点展开，如果虚转移节点修饰的节点的默认转移路径指向NFA的结束状态，则将虚转移包含的第一个转移赋给默认转移路径，剩下的再正常展开。

最后，根据映射表再遍历一遍NFA的每个节点，将所有的转移路径映射到新转移路径。

### 1.2.8

处理含有空字符串的或运算。

### 1.2.9

如果或运算的前驱字符是左括号，或者后继字符是右括号，或者前驱字符后继字符任意一个也是或运算，则认为这个表达式是无效的。

### 1.2.10

添加了对于不成对括号的检查。

### 1.2.11

当遇到或运算的后继为左括号时，记录或运算的嵌套层数，用于调整：写入前驱队列和后继队列时往倒数第(嵌套层数+1)个元素中写入。

在遇到右括号时，嵌套结束，减少记录的一层嵌套层数。

## 1.3 支持闭包运算的转换

## 1.4 支持反运算的转换